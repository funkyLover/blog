---
layout: post
title: "2019-05-10"
date: 2019-05-10
tags: [webpack, vue, node]
comments: true
share: true
---

> [2019-05-19]mac 生成 pkcs12 格式 ssl 证书 <br>
> [2019-05-18]webpack 指定多个静态文件夹 <br>
> [2019-05-14]vue-cli 使用 npm script 指定配置文件路径, 在 windows 下不能正常识别 <br>
> [2019-05-14]git 子模块相关命令 <br>
> [2019-05-11]vue-cli3.x 脚手架生成的项目, vue.config.js 使用 pages 配置多页应用时, 无法指定 template loader <br>
> [2019-05-10]webpack 使用动态加载`import()`引入的 ES6 模块, 需要通过 default 属性才能获取到模块内容

##### [2019-05-19]mac 生成 pkcs12 ssl 证书

```bash
openssl genrsa -out key.pem

openssl req -new -key myKey.pem -out cert.csr

openssl x509 -req -in cert.csr -signkey key.pem -out cert.crt

openssl pkcs12 -export -in cert.crt -inkey key.pem -out cert.p12
```

##### [2019-05-18]webpack 指定多个静态文件夹

有一些资源, 基本不会发生改动, 所以并不想经过打包构建处理

这个时候一般可以指定一个存放这些静态资源的目录, 通过 `webpack.devServer.contenBase` 参数去指定

然后在 html 模板中直接引用, 而生产构建流程则要使用[copy-webpack-plugin](https://github.com/webpack-contrib/copy-webpack-plugin)把静态目录 copy 到`dist`下

大致配置如下

```js
// webpack.devServer.contentBase
{
  // ...
  devServer: {
    contentBase: path.join(process.cwd(), "src/static");
  }
  // ...
  plugins: [
    // ...
    new CopyWebpackPlugin([
      {
        from: path.join(process.cwd(), "src/static"),
        to: path.join(process.cwd(), "dist"),
        ignore: [".*"]
      }
    ])
  ];
}
```

```html
<!-- src/static/logo.png -->
<img src="<%= BASE_URL %>/logo.png" />
```

这里需要注意 `webpack.devServer.contenBase` 是可以指定多个目录的, 如

```js
devServer: {
  contentBase: [
    path.join(process.cwd(), "src/static"),
    path.join(process.cwd(), "plugin")
  ];
}
```

如非必要的情况慎用此特性, 如果要使用就要小心维护避免两边出现同名文件

##### [2019-05-14]vue-cli 使用 npm script 指定配置文件路径, 在 windows 下不能正常识别

一开始使用 vue-cli 构建项目时, 使用下面的 npm script 去指定配置文件

```js
scripts: {
  "serve": "VUE_CLI_SERVICE_CONFIG_PATH=$PWD vue-cli-service serve"
}
```

使用上面写法, 在 mac 平台下没有出现问题, 结果在 windows 下翻车了

首先想到的是通过命令设置`process.env`值时, 需要处理平台的兼容性, 就引入了`cross-env`

```js
scripts: {
  "serve": "cross-env VUE_CLI_SERVICE_CONFIG_PATH=$PWD/build/vue.config.js vue-cli-service serve"
}
```

结果发现还是翻车了, 最终通过调试才发现, 原来 windows 下`process.env`中并没有`PWD`值

所以写在 script 中的`$PWD`并没有正确解析成当前项目路径, 进而导致配置文件拼接错误

唯有把启动逻辑单独写了脚本, 再通过 npm script 调用, 最终改造如下

```js
scripts: {
  "serve": "node ./script/run vue-cli-service serve"
}

// script/run.js
const path = require('path');
const crossEnv = require('cross-env');
const cwd = process.cwd();

const args = process.argv.slice(2);
const vueConfigDefault = process.env.VUE_CLI_SERVICE_CONFIG_PATH || './build/vue.config.js';

if (process.env.VUE_CLI_SERVICE_CONFIG_PATH) {
    args[0] = `VUE_CLI_SERVICE_CONFIG_PATH=${path.resolve(cwd, args[0].split('=')[1])}`;
} else {
    args.unshift(`VUE_CLI_SERVICE_CONFIG_PATH=${path.resolve(cwd, vueConfigDefault)}`);
}

crossEnv(args);
```

##### [2019-05-14]git 子模块相关命令

```bash
# 下载一个包含子模块的工程
git clone --recursive https://git.......

# 在已经下载的git仓库下更新子模块
git submodule update --init --recursive
```

##### [2019-05-11]vue-cli3.x 脚手架生成的项目, vue.config.js 使用 pages 配置多页应用时, 无法指定 template loader

在配置多页应用时指定 template 模板, 但是却在构建时却发现使用了 vue-cli 自带的模板, 使用`vue inspect`来检查生成的 webpack 配置时也的确是使用的自带模板

```js
// vue.config.js
pages: {
    about: {
        entry: 'src/pages/about/index.js',
        template: `!!${path.resolve(__dirname, './lib/loader/html.js')}!${'about.shtml'}`,
        filename: 'about.shtml',
        chunks: ['chunk-vendors', 'chunk-common', 'about'],
        minify: false
    }
}

// 最终生成配置
new HtmlWebpackPlugin(
  {
    templateParameters: function () { /* omitted long function */ },
    chunks: [
      'chunk-vendors',
      'chunk-common',
      'about'
    ],
    template: '/path/to/node_modules/@vue/cli-service/lib/config/index-default.html',
    filename: 'about.shtml',
    minify: false
  }
)
```

看`@vue/cli-service`源码时发现, 在配置`html-webpack-plugin`前, 会先检查 template 是否存在, 如果不存在的话会重新赋值成默认模板, 这里应该是`检查template是否存在`时出了问题

已经把 bug 反馈到[vue-cli#3976](https://github.com/vuejs/vue-cli/issues/3976)

##### [2019-05-10]webpack 使用动态加载`import()`引入的 ES6 模块, 需要通过 default 属性才能获取到模块内容

```js
// m.js

export default function() {}

// webpack import()

import("./m").then(m => m()); // Uncaught (in promise) TypeError: m is not a function
import("./m")
  .then(m => m.default)
  .then(m => m()); // correct
```

这个其实是[proposal-dynamic-import 规范](https://github.com/tc39/proposal-dynamic-import)定义的行为

简单来说`import('module')`代表的是`import * as module from 'module'`, 而非`import module from 'module'`

相关 issue: [proposal-dynamic-import#21](https://github.com/tc39/proposal-dynamic-import/issues/21), [webpack#3829](https://github.com/webpack/webpack/issues/3829)
